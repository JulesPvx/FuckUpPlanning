<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CopilotDiffPersistence">
    <option name="pendingDiffs">
      <map>
        <entry key="$PROJECT_DIR$/app/src/main/java/fr/uptrash/fuckupplanning/util/ICalParser.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/fr/uptrash/fuckupplanning/util/ICalParser.kt" />
              <option name="originalContent" value="package fr.uptrash.fuckupplanning.util&#10;&#10;import fr.uptrash.fuckupplanning.data.model.Event&#10;import kotlinx.datetime.LocalDateTime&#10;import kotlinx.datetime.toInstant&#10;import kotlinx.datetime.toLocalDateTime&#10;import javax.inject.Inject&#10;import javax.inject.Singleton&#10;import kotlin.time.ExperimentalTime&#10;&#10;@Singleton&#10;class ICalParser @Inject constructor() {&#10;&#10;    fun parseICalData(iCalData: String): List&lt;Event&gt; {&#10;        val events = mutableListOf&lt;Event&gt;()&#10;        val lines = iCalData.lines()&#10;&#10;        var i = 0&#10;        while (i &lt; lines.size) {&#10;            if (lines[i] == &quot;BEGIN:VEVENT&quot;) {&#10;                val event = parseEvent(lines, i)&#10;                if (event != null) {&#10;                    events.add(event)&#10;                }&#10;            }&#10;            i++&#10;        }&#10;&#10;        // Merge events with same summary and location&#10;        val mergedEvents = mergeEventsWithSameNameAndLocation(events)&#10;&#10;        return mergedEvents.sortedBy { it.startDateTime }&#10;    }&#10;&#10;    // Data class to use as a key for grouping events that can be merged&#10;    private data class EventMergeKey(&#10;        val summary: String,&#10;        val description: String?,&#10;        val location: String?,&#10;        val courseType: String?,&#10;        val instructor: String?,&#10;        val groups: List&lt;String&gt;,&#10;        val notes: String?,&#10;        val lastUpdated: String?,&#10;        val dtstamp: String?,&#10;        val created: String?,&#10;        val lastModified: String?,&#10;        val sequence: String?&#10;    )&#10;&#10;    private fun mergeEventsWithSameNameAndLocation(events: List&lt;Event&gt;): List&lt;Event&gt; {&#10;        val groupedEvents = events.groupBy { event -&gt;&#10;            // Group by ALL fields except start and end times&#10;            EventMergeKey(&#10;                summary = event.summary,&#10;                description = event.description,&#10;                location = event.location,&#10;                courseType = event.courseType,&#10;                instructor = event.instructor,&#10;                groups = event.groups,&#10;                notes = event.notes,&#10;                lastUpdated = event.lastUpdated,&#10;                dtstamp = event.dtstamp,&#10;                created = event.created,&#10;                lastModified = event.lastModified,&#10;                sequence = event.sequence&#10;            )&#10;        }&#10;&#10;        val mergedEvents = mutableListOf&lt;Event&gt;()&#10;&#10;        for ((_, eventGroup) in groupedEvents) {&#10;            if (eventGroup.size == 1) {&#10;                // No merging needed for single events&#10;                mergedEvents.add(eventGroup.first())&#10;            } else {&#10;                // Sort events by start time and merge adjacent/overlapping ones&#10;                val sortedEvents = eventGroup.sortedBy { it.startDateTime }&#10;                val merged = mergeAdjacentEvents(sortedEvents)&#10;                mergedEvents.addAll(merged)&#10;            }&#10;        }&#10;&#10;        return mergedEvents&#10;    }&#10;&#10;    // Data class to use as a key for grouping events that can be merged&#10;    private data class EventMergeKey(&#10;        val summary: String,&#10;        val description: String?,&#10;        val location: String?,&#10;        val courseType: String?,&#10;        val instructor: String?,&#10;        val groups: List&lt;String&gt;,&#10;        val notes: String?,&#10;        val lastUpdated: String?,&#10;        val dtstamp: String?,&#10;        val created: String?,&#10;        val lastModified: String?,&#10;        val sequence: String?&#10;    )&#10;&#10;    private fun mergeAdjacentEvents(sortedEvents: List&lt;Event&gt;): List&lt;Event&gt; {&#10;        if (sortedEvents.isEmpty()) return emptyList()&#10;&#10;        val merged = mutableListOf&lt;Event&gt;()&#10;        var currentEvent = sortedEvents.first()&#10;&#10;        for (i in 1 until sortedEvents.size) {&#10;            val nextEvent = sortedEvents[i]&#10;&#10;            // Check if events are adjacent or overlapping&#10;            if (currentEvent.endDateTime &gt;= nextEvent.startDateTime) {&#10;                // Merge the events&#10;                currentEvent = mergeEvents(currentEvent, nextEvent)&#10;            } else {&#10;                // Events are not adjacent, add current to result and start new&#10;                merged.add(currentEvent)&#10;                currentEvent = nextEvent&#10;            }&#10;        }&#10;&#10;        // Add the last event&#10;        merged.add(currentEvent)&#10;        return merged&#10;    }&#10;&#10;    private fun mergeEvents(event1: Event, event2: Event): Event {&#10;        // Take the earliest start time and latest end time&#10;        val startDateTime =&#10;            if (event1.startDateTime &lt;= event2.startDateTime) event1.startDateTime else event2.startDateTime&#10;        val endDateTime =&#10;            if (event1.endDateTime &gt;= event2.endDateTime) event1.endDateTime else event2.endDateTime&#10;&#10;        // Combine UIDs to track merged events&#10;        val combinedUid = &quot;${event1.uid},${event2.uid}&quot;&#10;&#10;        // Merge descriptions, notes, and other fields&#10;        val combinedDescription = listOfNotNull(event1.description, event2.description)&#10;            .distinct()&#10;            .joinToString(&quot;\n&quot;)&#10;            .takeIf { it.isNotEmpty() }&#10;&#10;        val combinedNotes = listOfNotNull(event1.notes, event2.notes)&#10;            .distinct()&#10;            .joinToString(&quot;\n&quot;)&#10;            .takeIf { it.isNotEmpty() }&#10;&#10;        val combinedGroups = (event1.groups + event2.groups).distinct()&#10;&#10;        // Use the most recent timestamps&#10;        val mostRecentEvent =&#10;            if (event1.lastModified.orEmpty() &gt;= event2.lastModified.orEmpty()) event1 else event2&#10;&#10;        return Event(&#10;            uid = combinedUid,&#10;            summary = event1.summary, // They should be the same&#10;            description = combinedDescription,&#10;            startDateTime = startDateTime,&#10;            endDateTime = endDateTime,&#10;            location = event1.location, // They should be the same&#10;            courseType = event1.courseType ?: event2.courseType,&#10;            instructor = event1.instructor ?: event2.instructor,&#10;            groups = combinedGroups,&#10;            notes = combinedNotes,&#10;            lastUpdated = event1.lastUpdated ?: event2.lastUpdated,&#10;            dtstamp = mostRecentEvent.dtstamp,&#10;            created = if (event1.created.orEmpty() &lt;= event2.created.orEmpty()) event1.created else event2.created,&#10;            lastModified = mostRecentEvent.lastModified,&#10;            sequence = maxOf(&#10;                event1.sequence?.toIntOrNull() ?: 0,&#10;                event2.sequence?.toIntOrNull() ?: 0&#10;            ).toString()&#10;        )&#10;    }&#10;&#10;    private fun parseEvent(lines: List&lt;String&gt;, startIndex: Int): Event? {&#10;        var uid = &quot;&quot;&#10;        var summary = &quot;&quot;&#10;        var description: String? = null&#10;        var startDateTime: LocalDateTime? = null&#10;        var endDateTime: LocalDateTime? = null&#10;        var location: String? = null&#10;        var dtstamp: String? = null&#10;        var created: String? = null&#10;        var lastModified: String? = null&#10;        var sequence: String? = null&#10;&#10;        var i = startIndex + 1&#10;        while (i &lt; lines.size &amp;&amp; lines[i] != &quot;END:VEVENT&quot;) {&#10;            val line = lines[i]&#10;            when {&#10;                line.startsWith(&quot;UID:&quot;) -&gt; uid = line.substringAfter(&quot;UID:&quot;)&#10;                line.startsWith(&quot;SUMMARY:&quot;) -&gt; summary = line.substringAfter(&quot;SUMMARY:&quot;)&#10;                line.startsWith(&quot;DESCRIPTION:&quot;) -&gt; description = line.substringAfter(&quot;DESCRIPTION:&quot;)&#10;                line.startsWith(&quot;DTSTART:&quot;) -&gt; {&#10;                    startDateTime = parseDateTime(line.substringAfter(&quot;DTSTART:&quot;))&#10;                }&#10;&#10;                line.startsWith(&quot;DTEND:&quot;) -&gt; {&#10;                    endDateTime = parseDateTime(line.substringAfter(&quot;DTEND:&quot;))&#10;                }&#10;&#10;                line.startsWith(&quot;LOCATION:&quot;) -&gt; location = line.substringAfter(&quot;LOCATION:&quot;)&#10;                line.startsWith(&quot;DTSTAMP:&quot;) -&gt; dtstamp = line.substringAfter(&quot;DTSTAMP:&quot;)&#10;                line.startsWith(&quot;CREATED:&quot;) -&gt; created = line.substringAfter(&quot;CREATED:&quot;)&#10;                line.startsWith(&quot;LAST-MODIFIED:&quot;) -&gt; lastModified =&#10;                    line.substringAfter(&quot;LAST-MODIFIED:&quot;)&#10;&#10;                line.startsWith(&quot;SEQUENCE:&quot;) -&gt; sequence = line.substringAfter(&quot;SEQUENCE:&quot;)&#10;            }&#10;            i++&#10;        }&#10;&#10;        val parsedDescription = parseDescription(description)&#10;&#10;        return if (uid.isNotEmpty() &amp;&amp; startDateTime != null &amp;&amp; endDateTime != null) {&#10;            Event(&#10;                uid = uid,&#10;                summary = formatEventTitle(summary),&#10;                description = parsedDescription.originalDescription,&#10;                startDateTime = startDateTime,&#10;                endDateTime = endDateTime,&#10;                location = formatLocation(location?.replace(&quot;\\,&quot;, &quot;,&quot;)),&#10;                courseType = parsedDescription.courseType,&#10;                instructor = parsedDescription.instructor,&#10;                groups = parsedDescription.groups,&#10;                notes = parsedDescription.notes,&#10;                lastUpdated = parsedDescription.lastUpdated,&#10;                dtstamp = dtstamp,&#10;                created = created,&#10;                lastModified = lastModified,&#10;                sequence = sequence&#10;            )&#10;        } else null&#10;    }&#10;&#10;    private data class ParsedDescription(&#10;        val originalDescription: String?,&#10;        val courseType: String?,&#10;        val instructor: String?,&#10;        val groups: List&lt;String&gt;,&#10;        val notes: String?,&#10;        val lastUpdated: String?&#10;    )&#10;&#10;    private fun parseDescription(description: String?): ParsedDescription {&#10;        if (description.isNullOrBlank()) {&#10;            return ParsedDescription(description, null, null, emptyList(), null, null)&#10;        }&#10;&#10;        // Clean up the description by removing escape sequences&#10;        val cleanDescription = description.replace(&quot;\\n&quot;, &quot;\n&quot;).replace(&quot;\\,&quot;, &quot;,&quot;)&#10;        val lines = cleanDescription.split(&quot;\n&quot;).map { it.trim() }.filter { it.isNotEmpty() }&#10;&#10;        var courseType: String? = null&#10;        var instructor: String? = null&#10;        var lastUpdated: String? = null&#10;        val groups = mutableListOf&lt;String&gt;()&#10;        val notesList = mutableListOf&lt;String&gt;()&#10;&#10;        for (line in lines) {&#10;            when {&#10;                // Check for course types (CM, TD, TDB, TDA, TP with numbers) - merge all into courseType&#10;                line.matches(Regex(&quot;^(CM|TDB?|TDA|TD\\d*|TP\\d+)$&quot;)) -&gt; {&#10;                    courseType = line&#10;                }&#10;                // Also check for course types that might be embedded in other text patterns&#10;                line.contains(Regex(&quot;\\b(CM|TDB?|TDA|TD\\d*|TP\\d+)\\b&quot;)) -&gt; {&#10;                    val courseTypeMatches = Regex(&quot;\\b(CM|TDB?|TDA|TD\\d*|TP\\d+)\\b&quot;).findAll(line)&#10;                    courseTypeMatches.forEach { match -&gt;&#10;                        if (courseType == null) {&#10;                            courseType = match.value&#10;                        }&#10;                    }&#10;                    // If the line contains other text, add it to notes&#10;                    val lineWithoutCourseType =&#10;                        line.replace(Regex(&quot;\\b(CM|TDB?|TDA|TD\\d*|TP\\d+)\\b&quot;), &quot;&quot;).trim()&#10;                    if (lineWithoutCourseType.isNotEmpty() &amp;&amp; !lineWithoutCourseType.matches(Regex(&quot;^\\s*$&quot;))) {&#10;                        notesList.add(lineWithoutCourseType)&#10;                    }&#10;                }&#10;                // Check for instructor names (mixed case: title case first name + uppercase last name, or all caps)&#10;                (line.matches(Regex(&quot;^\\p{Lu}+(?:-\\p{Lu}+)* \\p{Lu}+(?:-\\p{Lu}+)*$&quot;)) || // All caps format&#10;                        line.matches(Regex(&quot;^\\p{Lu}\\p{Ll}+(?:-\\p{Lu}\\p{Ll}+)* \\p{Lu}+(?:-\\p{Lu}+)*$&quot;))) &amp;&amp; // Mixed case format&#10;                        !line.contains(&quot;BUT&quot;) -&gt; {&#10;                    instructor = line&#10;                }&#10;                // Check for update timestamp&#10;                line.startsWith(&quot;(Updated :&quot;) &amp;&amp; line.endsWith(&quot;)&quot;) -&gt; {&#10;                    lastUpdated = line.removePrefix(&quot;(Updated :&quot;).removeSuffix(&quot;)&quot;)&#10;                }&#10;                // Everything else goes to notes&#10;                else -&gt; {&#10;                    if (line.isNotEmpty() &amp;&amp; !line.matches(Regex(&quot;^\\s*$&quot;))) {&#10;                        notesList.add(line)&#10;                    }&#10;                }&#10;            }&#10;        }&#10;&#10;        val notes = if (notesList.isNotEmpty()) notesList.joinToString(&quot;\n&quot;) else null&#10;&#10;        return ParsedDescription(&#10;            originalDescription = description,&#10;            courseType = courseType,&#10;            instructor = instructor,&#10;            groups = groups,&#10;            notes = notes,&#10;            lastUpdated = lastUpdated&#10;        )&#10;    }&#10;&#10;    private fun formatEventTitle(title: String): String {&#10;        // Only format titles that start with R followed by digits, dot, digits (like R3.12-dev front-info)&#10;        if (title.matches(Regex(&quot;^R\\d+\\.\\d+.*&quot;))) {&#10;            // Split on hyphen to separate room/code from subject&#10;            val parts = title.split(&quot;-&quot;, limit = 2)&#10;            if (parts.size == 2) {&#10;                val roomCode = parts[0].trim() // e.g., &quot;R3.12&quot;&#10;                val subject = parts[1].trim() // e.g., &quot;dev front-info&quot;&#10;&#10;                // Capitalize first letter of each word in the subject&#10;                val formattedSubject = subject.split(&quot; &quot;).joinToString(&quot; &quot;) { word -&gt;&#10;                    word.lowercase()&#10;                        .replaceFirstChar { if (it.isLowerCase()) it.titlecase() else it.toString() }&#10;                }&#10;&#10;                return &quot;$roomCode - $formattedSubject&quot;&#10;            }&#10;        }&#10;&#10;        // Return original title if it doesn't match the pattern or doesn't contain a hyphen&#10;        return title&#10;    }&#10;&#10;    private fun formatLocation(location: String?): String? {&#10;        if (location.isNullOrBlank()) return location&#10;&#10;        // Handle multiple rooms separated by commas without spaces (e.g., &quot;MMI300,MMI301&quot;)&#10;        return location.split(&quot;,&quot;).joinToString(&quot;, &quot;) { room -&gt;&#10;            room.trim()&#10;        }&#10;    }&#10;&#10;    @OptIn(ExperimentalTime::class)&#10;    private fun parseDateTime(dateTimeString: String): LocalDateTime? {&#10;        return try {&#10;            // iCal format: YYYYMMDDTHHMMSS or YYYYMMDDTHHMMSSZ&#10;            val isUtc = dateTimeString.endsWith(&quot;Z&quot;)&#10;            val cleanedString = dateTimeString.replace(&quot;Z&quot;, &quot;&quot;).trim()&#10;&#10;            if (cleanedString.length &gt;= 13) {&#10;                val year = cleanedString.substring(0, 4).toInt()&#10;                val month = cleanedString.substring(4, 6).toInt()&#10;                val day = cleanedString.substring(6, 8).toInt()&#10;                val hour = cleanedString.substring(9, 11).toInt()&#10;                val minute = cleanedString.substring(11, 13).toInt()&#10;                val second = if (cleanedString.length &gt;= 15) {&#10;                    cleanedString.substring(13, 15).toInt()&#10;                } else {&#10;                    0&#10;                }&#10;&#10;                val localDateTime = LocalDateTime(year, month, day, hour, minute, second)&#10;&#10;                // If the timestamp is in UTC (ends with Z), convert to local time&#10;                if (isUtc) {&#10;                    val instant = localDateTime.toInstant(kotlinx.datetime.TimeZone.UTC)&#10;                    instant.toLocalDateTime(kotlinx.datetime.TimeZone.currentSystemDefault())&#10;                } else {&#10;                    localDateTime&#10;                }&#10;            } else {&#10;                null&#10;            }&#10;        } catch (_: Exception) {&#10;            null&#10;        }&#10;    }&#10;}" />
              <option name="updatedContent" value="package fr.uptrash.fuckupplanning.util&#10;&#10;import fr.uptrash.fuckupplanning.data.model.Event&#10;import kotlinx.datetime.LocalDateTime&#10;import kotlinx.datetime.toInstant&#10;import kotlinx.datetime.toLocalDateTime&#10;import javax.inject.Inject&#10;import javax.inject.Singleton&#10;import kotlin.time.ExperimentalTime&#10;&#10;@Singleton&#10;class ICalParser @Inject constructor() {&#10;&#10;    fun parseICalData(iCalData: String): List&lt;Event&gt; {&#10;        val events = mutableListOf&lt;Event&gt;()&#10;        val lines = iCalData.lines()&#10;&#10;        var i = 0&#10;        while (i &lt; lines.size) {&#10;            if (lines[i] == &quot;BEGIN:VEVENT&quot;) {&#10;                val event = parseEvent(lines, i)&#10;                if (event != null) {&#10;                    events.add(event)&#10;                }&#10;            }&#10;            i++&#10;        }&#10;&#10;        // Merge events with same summary and location&#10;        val mergedEvents = mergeEventsWithSameNameAndLocation(events)&#10;&#10;        return mergedEvents.sortedBy { it.startDateTime }&#10;    }&#10;&#10;    // Data class to use as a key for grouping events that can be merged&#10;    private data class EventMergeKey(&#10;        val summary: String,&#10;        val description: String?,&#10;        val location: String?,&#10;        val courseType: String?,&#10;        val instructor: String?,&#10;        val groups: List&lt;String&gt;,&#10;        val notes: String?,&#10;        val lastUpdated: String?,&#10;        val dtstamp: String?,&#10;        val created: String?,&#10;        val lastModified: String?,&#10;        val sequence: String?&#10;    )&#10;&#10;    private fun mergeEventsWithSameNameAndLocation(events: List&lt;Event&gt;): List&lt;Event&gt; {&#10;        val groupedEvents = events.groupBy { event -&gt;&#10;            // Group by ALL fields except start and end times&#10;            EventMergeKey(&#10;                summary = event.summary,&#10;                description = event.description,&#10;                location = event.location,&#10;                courseType = event.courseType,&#10;                instructor = event.instructor,&#10;                groups = event.groups,&#10;                notes = event.notes,&#10;                lastUpdated = event.lastUpdated,&#10;                dtstamp = event.dtstamp,&#10;                created = event.created,&#10;                lastModified = event.lastModified,&#10;                sequence = event.sequence&#10;            )&#10;        }&#10;&#10;        val mergedEvents = mutableListOf&lt;Event&gt;()&#10;&#10;        for ((_, eventGroup) in groupedEvents) {&#10;            if (eventGroup.size == 1) {&#10;                // No merging needed for single events&#10;                mergedEvents.add(eventGroup.first())&#10;            } else {&#10;                // Sort events by start time and merge adjacent/overlapping ones&#10;                val sortedEvents = eventGroup.sortedBy { it.startDateTime }&#10;                val merged = mergeAdjacentEvents(sortedEvents)&#10;                mergedEvents.addAll(merged)&#10;            }&#10;        }&#10;&#10;        return mergedEvents&#10;    }&#10;&#10;    // Data class to use as a key for grouping events that can be merged&#10;    private data class EventMergeKey(&#10;        val summary: String,&#10;        val description: String?,&#10;        val location: String?,&#10;        val courseType: String?,&#10;        val instructor: String?,&#10;        val groups: List&lt;String&gt;,&#10;        val notes: String?,&#10;        val lastUpdated: String?,&#10;        val dtstamp: String?,&#10;        val created: String?,&#10;        val lastModified: String?,&#10;        val sequence: String?&#10;    )&#10;    private fun mergeAdjacentEvents(sortedEvents: List&lt;Event&gt;): List&lt;Event&gt; {&#10;        if (sortedEvents.isEmpty()) return emptyList()&#10;&#10;        val merged = mutableListOf&lt;Event&gt;()&#10;        var currentEvent = sortedEvents.first()&#10;&#10;        for (i in 1 until sortedEvents.size) {&#10;            val nextEvent = sortedEvents[i]&#10;&#10;            // Check if events are adjacent or overlapping&#10;            if (currentEvent.endDateTime &gt;= nextEvent.startDateTime) {&#10;                // Merge the events&#10;                currentEvent = mergeEvents(currentEvent, nextEvent)&#10;            } else {&#10;                // Events are not adjacent, add current to result and start new&#10;                merged.add(currentEvent)&#10;                currentEvent = nextEvent&#10;            }&#10;        }&#10;&#10;        // Add the last event&#10;        merged.add(currentEvent)&#10;        return merged&#10;    }&#10;&#10;    private fun mergeEvents(event1: Event, event2: Event): Event {&#10;        // Take the earliest start time and latest end time&#10;        val startDateTime =&#10;            if (event1.startDateTime &lt;= event2.startDateTime) event1.startDateTime else event2.startDateTime&#10;        val endDateTime =&#10;            if (event1.endDateTime &gt;= event2.endDateTime) event1.endDateTime else event2.endDateTime&#10;&#10;        // Combine UIDs to track merged events&#10;        val combinedUid = &quot;${event1.uid},${event2.uid}&quot;&#10;&#10;        // Merge descriptions, notes, and other fields&#10;        val combinedDescription = listOfNotNull(event1.description, event2.description)&#10;            .distinct()&#10;            .joinToString(&quot;\n&quot;)&#10;            .takeIf { it.isNotEmpty() }&#10;&#10;        val combinedNotes = listOfNotNull(event1.notes, event2.notes)&#10;            .distinct()&#10;            .joinToString(&quot;\n&quot;)&#10;            .takeIf { it.isNotEmpty() }&#10;&#10;        val combinedGroups = (event1.groups + event2.groups).distinct()&#10;&#10;        // Use the most recent timestamps&#10;        val mostRecentEvent =&#10;            if (event1.lastModified.orEmpty() &gt;= event2.lastModified.orEmpty()) event1 else event2&#10;&#10;        return Event(&#10;            uid = combinedUid,&#10;            summary = event1.summary, // They should be the same&#10;            description = combinedDescription,&#10;            startDateTime = startDateTime,&#10;            endDateTime = endDateTime,&#10;            location = event1.location, // They should be the same&#10;            courseType = event1.courseType ?: event2.courseType,&#10;            instructor = event1.instructor ?: event2.instructor,&#10;            groups = combinedGroups,&#10;            notes = combinedNotes,&#10;            lastUpdated = event1.lastUpdated ?: event2.lastUpdated,&#10;            dtstamp = mostRecentEvent.dtstamp,&#10;            created = if (event1.created.orEmpty() &lt;= event2.created.orEmpty()) event1.created else event2.created,&#10;            lastModified = mostRecentEvent.lastModified,&#10;            sequence = maxOf(&#10;                event1.sequence?.toIntOrNull() ?: 0,&#10;                event2.sequence?.toIntOrNull() ?: 0&#10;            ).toString()&#10;        )&#10;    }&#10;&#10;    private fun parseEvent(lines: List&lt;String&gt;, startIndex: Int): Event? {&#10;        var uid = &quot;&quot;&#10;        var summary = &quot;&quot;&#10;        var description: String? = null&#10;        var startDateTime: LocalDateTime? = null&#10;        var endDateTime: LocalDateTime? = null&#10;        var location: String? = null&#10;        var dtstamp: String? = null&#10;        var created: String? = null&#10;        var lastModified: String? = null&#10;        var sequence: String? = null&#10;&#10;        var i = startIndex + 1&#10;        while (i &lt; lines.size &amp;&amp; lines[i] != &quot;END:VEVENT&quot;) {&#10;            val line = lines[i]&#10;            when {&#10;                line.startsWith(&quot;UID:&quot;) -&gt; uid = line.substringAfter(&quot;UID:&quot;)&#10;                line.startsWith(&quot;SUMMARY:&quot;) -&gt; summary = line.substringAfter(&quot;SUMMARY:&quot;)&#10;                line.startsWith(&quot;DESCRIPTION:&quot;) -&gt; description = line.substringAfter(&quot;DESCRIPTION:&quot;)&#10;                line.startsWith(&quot;DTSTART:&quot;) -&gt; {&#10;                    startDateTime = parseDateTime(line.substringAfter(&quot;DTSTART:&quot;))&#10;                }&#10;&#10;                line.startsWith(&quot;DTEND:&quot;) -&gt; {&#10;                    endDateTime = parseDateTime(line.substringAfter(&quot;DTEND:&quot;))&#10;                }&#10;&#10;                line.startsWith(&quot;LOCATION:&quot;) -&gt; location = line.substringAfter(&quot;LOCATION:&quot;)&#10;                line.startsWith(&quot;DTSTAMP:&quot;) -&gt; dtstamp = line.substringAfter(&quot;DTSTAMP:&quot;)&#10;                line.startsWith(&quot;CREATED:&quot;) -&gt; created = line.substringAfter(&quot;CREATED:&quot;)&#10;                line.startsWith(&quot;LAST-MODIFIED:&quot;) -&gt; lastModified =&#10;                    line.substringAfter(&quot;LAST-MODIFIED:&quot;)&#10;&#10;                line.startsWith(&quot;SEQUENCE:&quot;) -&gt; sequence = line.substringAfter(&quot;SEQUENCE:&quot;)&#10;            }&#10;            i++&#10;        }&#10;&#10;        val parsedDescription = parseDescription(description)&#10;&#10;        return if (uid.isNotEmpty() &amp;&amp; startDateTime != null &amp;&amp; endDateTime != null) {&#10;            Event(&#10;                uid = uid,&#10;                summary = formatEventTitle(summary),&#10;                description = parsedDescription.originalDescription,&#10;                startDateTime = startDateTime,&#10;                endDateTime = endDateTime,&#10;                location = formatLocation(location?.replace(&quot;\\,&quot;, &quot;,&quot;)),&#10;                courseType = parsedDescription.courseType,&#10;                instructor = parsedDescription.instructor,&#10;                groups = parsedDescription.groups,&#10;                notes = parsedDescription.notes,&#10;                lastUpdated = parsedDescription.lastUpdated,&#10;                dtstamp = dtstamp,&#10;                created = created,&#10;                lastModified = lastModified,&#10;                sequence = sequence&#10;            )&#10;        } else null&#10;    }&#10;&#10;    private data class ParsedDescription(&#10;        val originalDescription: String?,&#10;        val courseType: String?,&#10;        val instructor: String?,&#10;        val groups: List&lt;String&gt;,&#10;        val notes: String?,&#10;        val lastUpdated: String?&#10;    )&#10;&#10;    private fun parseDescription(description: String?): ParsedDescription {&#10;        if (description.isNullOrBlank()) {&#10;            return ParsedDescription(description, null, null, emptyList(), null, null)&#10;        }&#10;&#10;        // Clean up the description by removing escape sequences&#10;        val cleanDescription = description.replace(&quot;\\n&quot;, &quot;\n&quot;).replace(&quot;\\,&quot;, &quot;,&quot;)&#10;        val lines = cleanDescription.split(&quot;\n&quot;).map { it.trim() }.filter { it.isNotEmpty() }&#10;&#10;        var courseType: String? = null&#10;        var instructor: String? = null&#10;        var lastUpdated: String? = null&#10;        val groups = mutableListOf&lt;String&gt;()&#10;        val notesList = mutableListOf&lt;String&gt;()&#10;&#10;        for (line in lines) {&#10;            when {&#10;                // Check for course types (CM, TD, TDB, TDA, TP with numbers) - merge all into courseType&#10;                line.matches(Regex(&quot;^(CM|TDB?|TDA|TD\\d*|TP\\d+)$&quot;)) -&gt; {&#10;                    courseType = line&#10;                }&#10;                // Also check for course types that might be embedded in other text patterns&#10;                line.contains(Regex(&quot;\\b(CM|TDB?|TDA|TD\\d*|TP\\d+)\\b&quot;)) -&gt; {&#10;                    val courseTypeMatches = Regex(&quot;\\b(CM|TDB?|TDA|TD\\d*|TP\\d+)\\b&quot;).findAll(line)&#10;                    courseTypeMatches.forEach { match -&gt;&#10;                        if (courseType == null) {&#10;                            courseType = match.value&#10;                        }&#10;                    }&#10;                    // If the line contains other text, add it to notes&#10;                    val lineWithoutCourseType =&#10;                        line.replace(Regex(&quot;\\b(CM|TDB?|TDA|TD\\d*|TP\\d+)\\b&quot;), &quot;&quot;).trim()&#10;                    if (lineWithoutCourseType.isNotEmpty() &amp;&amp; !lineWithoutCourseType.matches(Regex(&quot;^\\s*$&quot;))) {&#10;                        notesList.add(lineWithoutCourseType)&#10;                    }&#10;                }&#10;                // Check for instructor names (mixed case: title case first name + uppercase last name, or all caps)&#10;                (line.matches(Regex(&quot;^\\p{Lu}+(?:-\\p{Lu}+)* \\p{Lu}+(?:-\\p{Lu}+)*$&quot;)) || // All caps format&#10;                        line.matches(Regex(&quot;^\\p{Lu}\\p{Ll}+(?:-\\p{Lu}\\p{Ll}+)* \\p{Lu}+(?:-\\p{Lu}+)*$&quot;))) &amp;&amp; // Mixed case format&#10;                        !line.contains(&quot;BUT&quot;) -&gt; {&#10;                    instructor = line&#10;                }&#10;                // Check for update timestamp&#10;                line.startsWith(&quot;(Updated :&quot;) &amp;&amp; line.endsWith(&quot;)&quot;) -&gt; {&#10;                    lastUpdated = line.removePrefix(&quot;(Updated :&quot;).removeSuffix(&quot;)&quot;)&#10;                }&#10;                // Everything else goes to notes&#10;                else -&gt; {&#10;                    if (line.isNotEmpty() &amp;&amp; !line.matches(Regex(&quot;^\\s*$&quot;))) {&#10;                        notesList.add(line)&#10;                    }&#10;                }&#10;            }&#10;        }&#10;&#10;        val notes = if (notesList.isNotEmpty()) notesList.joinToString(&quot;\n&quot;) else null&#10;&#10;        return ParsedDescription(&#10;            originalDescription = description,&#10;            courseType = courseType,&#10;            instructor = instructor,&#10;            groups = groups,&#10;            notes = notes,&#10;            lastUpdated = lastUpdated&#10;        )&#10;    }&#10;&#10;    private fun formatEventTitle(title: String): String {&#10;        // Only format titles that start with R followed by digits, dot, digits (like R3.12-dev front-info)&#10;        if (title.matches(Regex(&quot;^R\\d+\\.\\d+.*&quot;))) {&#10;            // Split on hyphen to separate room/code from subject&#10;            val parts = title.split(&quot;-&quot;, limit = 2)&#10;            if (parts.size == 2) {&#10;                val roomCode = parts[0].trim() // e.g., &quot;R3.12&quot;&#10;                val subject = parts[1].trim() // e.g., &quot;dev front-info&quot;&#10;&#10;                // Capitalize first letter of each word in the subject&#10;                val formattedSubject = subject.split(&quot; &quot;).joinToString(&quot; &quot;) { word -&gt;&#10;                    word.lowercase()&#10;                        .replaceFirstChar { if (it.isLowerCase()) it.titlecase() else it.toString() }&#10;                }&#10;&#10;                return &quot;$roomCode - $formattedSubject&quot;&#10;            }&#10;        }&#10;&#10;        // Return original title if it doesn't match the pattern or doesn't contain a hyphen&#10;        return title&#10;    }&#10;&#10;    private fun formatLocation(location: String?): String? {&#10;        if (location.isNullOrBlank()) return location&#10;&#10;        // Handle multiple rooms separated by commas without spaces (e.g., &quot;MMI300,MMI301&quot;)&#10;        return location.split(&quot;,&quot;).joinToString(&quot;, &quot;) { room -&gt;&#10;            room.trim()&#10;        }&#10;    }&#10;&#10;    @OptIn(ExperimentalTime::class)&#10;    private fun parseDateTime(dateTimeString: String): LocalDateTime? {&#10;        return try {&#10;            // iCal format: YYYYMMDDTHHMMSS or YYYYMMDDTHHMMSSZ&#10;            val isUtc = dateTimeString.endsWith(&quot;Z&quot;)&#10;            val cleanedString = dateTimeString.replace(&quot;Z&quot;, &quot;&quot;).trim()&#10;&#10;            if (cleanedString.length &gt;= 13) {&#10;                val year = cleanedString.substring(0, 4).toInt()&#10;                val month = cleanedString.substring(4, 6).toInt()&#10;                val day = cleanedString.substring(6, 8).toInt()&#10;                val hour = cleanedString.substring(9, 11).toInt()&#10;                val minute = cleanedString.substring(11, 13).toInt()&#10;                val second = if (cleanedString.length &gt;= 15) {&#10;                    cleanedString.substring(13, 15).toInt()&#10;                } else {&#10;                    0&#10;                }&#10;&#10;                val localDateTime = LocalDateTime(year, month, day, hour, minute, second)&#10;&#10;                // If the timestamp is in UTC (ends with Z), convert to local time&#10;                if (isUtc) {&#10;                    val instant = localDateTime.toInstant(kotlinx.datetime.TimeZone.UTC)&#10;                    instant.toLocalDateTime(kotlinx.datetime.TimeZone.currentSystemDefault())&#10;                } else {&#10;                    localDateTime&#10;                }&#10;            } else {&#10;                null&#10;            }&#10;        } catch (_: Exception) {&#10;            null&#10;        }&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>